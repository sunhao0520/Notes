<!DOCTYPE html>
<html>
<head>
<title>pygame 快速入门</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>pygame 快速入门</h1>
<h2>目标</h2>
<ol>
<li>项目准备</li>
<li>使用 <code>pygame</code> 创建图形窗口</li>
<li>理解 <strong>图像</strong> 并实现图像绘制</li>
<li>理解 <strong>游戏循环</strong> 和 <strong>游戏时钟</strong></li>
<li>理解 <strong>精灵</strong> 和 <strong>精灵组</strong></li>
</ol>
<h2>项目准备</h2>
<ol>
<li>新建 <strong>飞机大战</strong> 项目</li>
<li>新建一个 <code>hm_01_pygame入门.py</code></li>
<li>导入 <strong>游戏素材图片</strong></li>
</ol>
<p><strong>游戏的第一印象</strong></p>
<ul>
<li>把一些 <strong>静止的图像</strong> 绘制到 <strong>游戏窗口</strong> 中</li>
<li>根据 <strong>用户的交互</strong> 或其他情况，<strong>移动</strong> 这些图像，产生动画效果</li>
<li>根据 <strong>图像之间</strong> 是否发生重叠，判断 <strong>敌机是否被摧毁</strong> 等其他情况</li>
</ul>
<h2>01. 使用 <code>pygame</code> 创建图形窗口</h2>
<h3>小节目标</h3>
<ol>
<li>游戏的初始化和退出</li>
<li>理解游戏中的坐标系</li>
<li>创建游戏主窗口</li>
<li>简单的游戏循环</li>
</ol>
<blockquote>
<p>可以将图片素材 <strong>绘制</strong> 到 <strong>游戏的窗口</strong> 上，开发游戏之前需要先知道 <strong>如何建立游戏窗口</strong>！</p>
</blockquote>
<h3>1.1 游戏的初始化和退出</h3>
<ul>
<li>要使用 <code>pygame</code> 提供的所有功能之前，需要调用 <code>init</code> 方法</li>
<li>在游戏结束前需要调用一下 <code>quit</code> 方法 </li>
</ul>
<p>| 方法 | 说明 |
| --- | --- |
| <code>pygame.init()</code> | 导入并初始化所有 <code>pygame</code> 模块，使用其他模块之前，必须先调用 <code>init</code> 方法 |
| <code>pygame.quit()</code> | 卸载所有 <code>pygame</code> 模块，在游戏结束之前调用！ |</p>
<p><img src="media/15025046487919/001_pygame%E7%9A%84init%E5%92%8Cquit.png" alt="001_pygame的init和quit-w254" /></p>
<p>```python
import pygame</p>
<p>pygame.init()</p>
<h1>游戏代码...</h1>
<p>pygame.quit()</p>
<p>```</p>
<h3>1.2 理解游戏中的坐标系</h3>
<ul>
<li>
<strong>坐标系</strong>
<ul>
<li><strong>原点</strong> 在 <strong>左上角</strong> <code>(0, 0)</code></li>
<li><strong>x 轴</strong> 水平方向向 <strong>右</strong>，逐渐增加</li>
<li><strong>y 轴</strong> 垂直方向向 <strong>下</strong>，逐渐增加</li>
</ul>
</li>
</ul>
<p><img src="media/15025046487919/002_%E6%B8%B8%E6%88%8F%E7%AA%97%E5%8F%A3%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="002_游戏窗口和坐标系-w300" /></p>
<ul>
<li>
<p>在游戏中，<strong>所有可见的元素</strong> 都是以 <strong>矩形区域</strong> 来描述位置的</p>
<ul>
<li>要描述一个矩形区域有四个要素：<code>(x, y) (width, height)</code></li>
</ul>
</li>
<li>
<p><code>pygame</code> 专门提供了一个类 <code>pygame.Rect</code> 用于描述 <strong>矩形区域</strong></p>
</li>
</ul>
<p><code>python
Rect(x, y, width, height) -&gt; Rect</code></p>
<p><img src="media/15025046487919/003_pygame.Rect.png" alt="003_pygame.Rect-w382" /></p>
<p><strong>提示</strong></p>
<ul>
<li><code>pygame.Rect</code> 是一个比较特殊的类，内部只是封装了一些数字计算</li>
<li>不执行 <code>pygame.init()</code> 方法同样能够直接使用</li>
</ul>
<h4>案例演练</h4>
<p><strong>需求</strong></p>
<ol>
<li>定义 <code>hero_rect</code> 矩形描述 <strong>英雄的位置和大小</strong></li>
<li>输出英雄的 <strong>坐标原点</strong>（<code>x</code> 和 <code>y</code>）</li>
<li>输出英雄的 <strong>尺寸</strong>（<strong>宽度</strong> 和 <strong>高度</strong>）</li>
</ol>
<p>```python
hero_rect = pygame.Rect(100, 500, 120, 126)</p>
<p>print(&quot;坐标原点 %d %d&quot; % (hero<em>rect.x, hero</em>rect.y))
print(&quot;英雄大小 %d %d&quot; % (hero<em>rect.width, hero</em>rect.height))</p>
<h1>size 属性会返回矩形区域的 (宽, 高) 元组</h1>
<p>print(&quot;英雄大小 %d %d&quot; % hero_rect.size)
```</p>
<h3>1.3 创建游戏主窗口</h3>
<ul>
<li><code>pygame</code> 专门提供了一个 <strong>模块</strong> <code>pygame.display</code> 用于创建、管理 <strong>游戏窗口</strong></li>
</ul>
<p>| 方法 | 说明 |
| --- | --- |
| <code>pygame.display.set_mode()</code> | 初始化游戏显示窗口 |
| <code>pygame.display.update()</code> | 刷新屏幕内容显示，稍后使用 | </p>
<p><strong><code>set_mode</code> 方法</strong></p>
<p><code>python
set_mode(resolution=(0,0), flags=0, depth=0) -&gt; Surface</code></p>
<ul>
<li><strong>作用</strong> —— 创建游戏显示窗口</li>
<li>
<strong>参数</strong>
<ul>
<li><code>resolution</code> 指定屏幕的 <code>宽</code> 和 <code>高</code>，默认创建的窗口大小和屏幕大小一致</li>
<li><code>flags</code> 参数指定屏幕的附加选项，例如是否全屏等等，默认不需要传递</li>
<li><code>depth</code> 参数表示颜色的位数，默认自动匹配</li>
</ul>
</li>
<li>
<p><strong>返回值</strong></p>
<ul>
<li><strong>暂时</strong> 可以理解为 <strong>游戏的屏幕<strong>，</strong>游戏的元素</strong> 都需要被绘制到 <strong>游戏的屏幕</strong> 上</li>
</ul>
</li>
<li>
<p><strong>注意</strong>：必须使用变量记录 <code>set_mode</code> 方法的返回结果！因为：后续所有的图像绘制都基于这个返回结果</p>
</li>
</ul>
<p>```python</p>
<h1>创建游戏主窗口</h1>
<p>screen = pygame.display.set_mode((480, 700))
```</p>
<h3>1.4 简单的游戏循环</h3>
<ul>
<li>为了做到游戏程序启动后，<strong>不会立即退出</strong>，通常会在游戏程序中增加一个 <strong>游戏循环</strong></li>
<li>所谓 <strong>游戏循环</strong> 就是一个 <strong>无限循环</strong></li>
<li>
在 <strong>创建游戏窗口</strong> 代码下方，增加一个无限循环
<ul>
<li>注意：<strong>游戏窗口不需要重复创建</strong></li>
</ul>
</li>
</ul>
<p>```python</p>
<h1>创建游戏主窗口</h1>
<p>screen = pygame.display.set_mode((480, 700))</p>
<h1>游戏循环</h1>
<p>while True:
    pass
```</p>
<h2>02. 理解 <strong>图像</strong> 并实现图像绘制</h2>
<ul>
<li>
在游戏中，能够看到的 <strong>游戏元素</strong> 大多都是 <strong>图像</strong>
<ul>
<li><strong>图像文件</strong> 初始是保存在磁盘上的，如果需要使用，<strong>第一步</strong> 就需要 <strong>被加载到内存</strong></li>
</ul>
</li>
<li>
要在屏幕上 <strong>看到某一个图像的内容</strong>，需要按照三个步骤：
<ol>
<li>使用 <code>pygame.image.load()</code> <strong>加载图像的数据</strong></li>
<li>使用 <strong>游戏屏幕</strong> 对象，调用 <code>blit</code> 方法 将图像绘制到指定位置</li>
<li>调用 <code>pygame.display.update()</code> 方法更新整个屏幕的显示</li>
</ol>
</li>
</ul>
<p><img src="media/15025046487919/004_%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F.png" alt="004_加载和显示图像-w841" /></p>
<blockquote>
<p>提示：要想在屏幕上看到绘制的结果，就一定要调用 <code>pygame.display.update()</code> 方法</p>
</blockquote>
<h3>代码演练 I —— 绘制背景图像</h3>
<p><strong>需求</strong></p>
<ol>
<li>加载 <code>background.png</code> 创建背景</li>
<li>将 <strong>背景</strong> 绘制在屏幕的 <code>(0, 0)</code> 位置</li>
<li>调用屏幕更新显示背景图像</li>
</ol>
<p>```python</p>
<h1>绘制背景图像</h1>
<h1>1&gt; 加载图像</h1>
<p>bg = pygame.image.load(&quot;./images/background.png&quot;)</p>
<h1>2&gt; 绘制在屏幕</h1>
<p>screen.blit(bg, (0, 0))</p>
<h1>3&gt; 更新显示</h1>
<p>pygame.display.update()
```</p>
<h3>代码演练 II —— 绘制英雄图像</h3>
<p><strong>需求</strong></p>
<ol>
<li>加载 <code>me1.png</code> 创建英雄飞机</li>
<li>将 <strong>英雄飞机</strong> 绘制在屏幕的 <code>(200, 500)</code> 位置</li>
<li>调用屏幕更新显示飞机图像</li>
</ol>
<p>```python</p>
<h1>1&gt; 加载图像</h1>
<p>hero = pygame.image.load(&quot;./images/me1.png&quot;)</p>
<h1>2&gt; 绘制在屏幕</h1>
<p>screen.blit(hero, (200, 500))</p>
<h1>3&gt; 更新显示</h1>
<p>pygame.display.update()
```</p>
<p><strong>透明图像</strong> </p>
<ul>
<li><code>png</code> 格式的图像是支持 <strong>透明</strong> 的</li>
<li>在绘制图像时，<strong>透明区域</strong> 不会显示任何内容</li>
<li>但是如果<strong>下方已经有内容</strong>，会 <strong>透过</strong> <strong>透明区域</strong> 显示出来</li>
</ul>
<h3>理解 <code>update()</code> 方法的作用</h3>
<blockquote>
<p>可以在 <code>screen</code> 对象完成 <strong>所有</strong> <code>blit</code> 方法之后，<strong>统一调用一次</strong> <code>display.update</code> 方法，同样可以在屏幕上 <strong>看到最终的绘制结果</strong></p>
</blockquote>
<ul>
<li>
使用 <code>display.set_mode()</code> 创建的 <code>screen</code> <strong>对象</strong> 是一个 <strong>内存中的屏幕数据对象</strong>
<ul>
<li>可以理解成是 <strong>油画</strong> 的 <strong>画布</strong></li>
</ul>
</li>
<li>
<code>screen.blit</code> 方法可以在 <strong>画布</strong> 上绘制很多 <strong>图像</strong>
<ul>
<li>例如：<strong>英雄</strong>、<strong>敌机<strong>、</strong>子弹</strong>...</li>
<li><strong>这些图像</strong> 有可能 会彼此 <strong>重叠或者覆盖</strong></li>
</ul>
</li>
<li><code>display.update()</code> 会将 <strong>画布</strong> 的 <strong>最终结果</strong> 绘制在屏幕上，这样可以 <strong>提高屏幕绘制效率</strong>，<strong>增加游戏的流畅度</strong></li>
</ul>
<p><strong>案例调整</strong></p>
<p>```python</p>
<h1>绘制背景图像</h1>
<h1>1&gt; 加载图像</h1>
<p>bg = pygame.image.load(&quot;./images/background.png&quot;)</p>
<h1>2&gt; 绘制在屏幕</h1>
<p>screen.blit(bg, (0, 0))</p>
<h1>绘制英雄图像</h1>
<h1>1&gt; 加载图像</h1>
<p>hero = pygame.image.load(&quot;./images/me1.png&quot;)</p>
<h1>2&gt; 绘制在屏幕</h1>
<p>screen.blit(hero, (200, 500))</p>
<h1>3&gt; 更新显示 - update 方法会把之前所有绘制的结果，一次性更新到屏幕窗口上</h1>
<p>pygame.display.update()
```</p>
<h2>03. 理解 <strong>游戏循环</strong> 和 <strong>游戏时钟</strong></h2>
<blockquote>
<p>现在 <strong>英雄飞机</strong> 已经被绘制到屏幕上了，<strong>怎么能够让飞机移动呢</strong> ？</p>
</blockquote>
<h3>3.1 游戏中的动画实现原理</h3>
<ul>
<li>
跟 <strong>电影</strong> 的原理类似，游戏中的动画效果，本质上是 <strong>快速</strong> 的在屏幕上绘制 <strong>图像</strong>
<ul>
<li>电影是将多张 <strong>静止的电影胶片</strong> <strong>连续、快速</strong>的播放，产生连贯的视觉效果！</li>
</ul>
</li>
<li>
一般在电脑上 <strong>每秒绘制 60 次</strong>，就能够达到非常 <strong>连续</strong> <strong>高品质</strong> 的动画效果
<ul>
<li>每次绘制的结果被称为 <strong>帧 Frame</strong></li>
</ul>
</li>
</ul>
<p><img src="media/15025046487919/%E6%89%8B%E7%BF%BB%E4%B9%A6%E5%8A%A8%E7%94%BB.gif" alt="手翻书动画" />
<img src="media/15025046487919/%E7%8C%AB%E6%83%8A%E8%AE%B6.gif" alt="猫惊讶" /></p>
<h3>3.2 <strong>游戏循环</strong></h3>
<h4>游戏的两个组成部分</h4>
<blockquote>
<p><strong>游戏循环的开始</strong> 就意味着 <strong>游戏的正式开始</strong></p>
</blockquote>
<p><img src="media/15025046487919/005_%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%A8%A1%E5%9D%97.png" alt="005_游戏主模块-w600" /></p>
<h4>游戏循环的作用</h4>
<ol>
<li>保证游戏 <strong>不会直接退出</strong></li>
<li>
<strong>变化图像位置</strong> —— 动画效果
<ul>
<li>每隔 <code>1 / 60 秒</code> 移动一下所有图像的位置</li>
<li>调用 <code>pygame.display.update()</code> 更新屏幕显示</li>
</ul>
</li>
<li><strong>检测用户交互</strong> —— 按键、鼠标等...</li>
</ol>
<h3>3.3 游戏时钟</h3>
<ul>
<li><code>pygame</code> 专门提供了一个类 <code>pygame.time.Clock</code> 可以非常方便的设置屏幕绘制速度 —— <strong>刷新帧率</strong></li>
<li>
要使用 <strong>时钟对象</strong> 需要两步：
<ul>
<li>1）在 <strong>游戏初始化</strong> 创建一个 <strong>时钟对象</strong></li>
<li>2）在 <strong>游戏循环</strong> 中让时钟对象调用 <code>tick(帧率)</code> 方法 </li>
</ul>
</li>
<li><code>tick</code> 方法会根据 <strong>上次被调用的时间</strong>，自动设置 <strong>游戏循环</strong> 中的延时</li>
</ul>
<p>```python</p>
<h1>3. 创建游戏时钟对象</h1>
<p>clock = pygame.time.Clock()
i = 0</p>
<h1>游戏循环</h1>
<p>while True:</p>
<pre><code># 设置屏幕刷新帧率
clock.tick(60)

print(i)
i += 1
</code></pre>

<p>```</p>
<h3>3.4 英雄的简单动画实现</h3>
<p><strong>需求</strong></p>
<ol>
<li>在 <strong>游戏初始化</strong> 定义一个 <code>pygame.Rect</code> 的变量记录英雄的初始位置</li>
<li>在 <strong>游戏循环</strong> 中每次让 <strong>英雄</strong> 的 <code>y - 1</code> —— 向上移动 </li>
<li><code>y &lt;= 0</code> 将英雄移动到屏幕的底部</li>
</ol>
<blockquote>
<p>提示：</p>
<ul>
<li>每一次调用 <code>update()</code> 方法之前，需要把 <strong>所有的游戏图像都重新绘制一遍</strong></li>
<li>而且应该 <strong>最先</strong> 重新绘制 <strong>背景图像</strong></li>
</ul>
</blockquote>
<p>```python</p>
<h1>4. 定义英雄的初始位置</h1>
<p>hero_rect = pygame.Rect(150, 500, 102, 126)</p>
<p>while True:</p>
<pre><code># 可以指定循环体内部的代码执行的频率
clock.tick(60)

# 更新英雄位置
hero_rect.y -= 1

# 如果移出屏幕，则将英雄的顶部移动到屏幕底部
if hero_rect.y &lt;= 0:
    hero_rect.y = 700

# 绘制背景图片
screen.blit(bg, (0, 0))
# 绘制英雄图像
screen.blit(hero, hero_rect)

# 更新显示
pygame.display.update()
</code></pre>

<p>```</p>
<h4>作业</h4>
<ol>
<li>英雄向上飞行，当 <strong>英雄完全从上方飞出屏幕后</strong></li>
<li>将飞机移动到屏幕的底部</li>
</ol>
<p><code>python
if hero_rect.y + hero_rect.height &lt;= 0:
    hero_rect.y = 700</code></p>
<p><strong>提示</strong></p>
<ul>
<li><code>Rect</code> 的属性 <code>bottom = y + height</code> </li>
</ul>
<p><code>python
if hero_rect.bottom &lt;= 0:
    hero_rect.y = 700</code></p>
<h3>3.5 在游戏循环中 监听 事件</h3>
<h4>事件 <code>event</code></h4>
<ul>
<li>就是游戏启动后，<strong>用户针对游戏所做的操作</strong></li>
<li>例如：<strong>点击关闭按钮</strong>，<strong>点击鼠标<strong>，</strong>按下键盘</strong>...</li>
</ul>
<h4>监听</h4>
<ul>
<li>在 <strong>游戏循环</strong> 中，判断用户 <strong>具体的操作</strong></li>
</ul>
<blockquote>
<p>只有 <strong>捕获</strong> 到用户具体的操作，才能有针对性的做出响应</p>
</blockquote>
<h4>代码实现</h4>
<ul>
<li>
<code>pygame</code> 中通过 <code>pygame.event.get()</code> 可以获得 <strong>用户当前所做动作</strong> 的 <strong>事件列表</strong>
<ul>
<li>用户可以同一时间做很多事情</li>
</ul>
</li>
<li>提示：<strong>这段代码非常的固定</strong>，几乎所有的 <code>pygame</code> 游戏都 <strong>大同小异</strong>！</li>
</ul>
<p>```python</p>
<h1>游戏循环</h1>
<p>while True:</p>
<pre><code># 设置屏幕刷新帧率
clock.tick(60)

# 事件监听
for event in pygame.event.get():

    # 判断用户是否点击了关闭按钮
    if event.type == pygame.QUIT:
        print(&quot;退出游戏...&quot;)

        pygame.quit()

        # 直接退出系统
        exit()
</code></pre>

<p>```</p>
<h2>04. 理解 <strong>精灵</strong> 和 <strong>精灵组</strong></h2>
<h3>4.1 精灵 和 精灵组</h3>
<ul>
<li>在刚刚完成的案例中，<strong>图像加载</strong>、<strong>位置变化<strong>、</strong>绘制图像</strong> 都需要程序员编写代码分别处理</li>
<li>
为了简化开发步骤，<code>pygame</code> 提供了两个类
<ul>
<li><code>pygame.sprite.Sprite</code> —— 存储 <strong>图像数据 image</strong> 和 <strong>位置 rect</strong> 的 <strong>对象</strong></li>
<li><code>pygame.sprite.Group</code></li>
</ul>
</li>
</ul>
<p><img src="media/15025046487919/006_pygame.Sprite.png" alt="006_pygame.Sprite" /></p>
<h4>精灵</h4>
<ul>
<li>在游戏开发中，通常把 <strong>显示图像的对象</strong> 叫做精灵 <code>Sprite</code></li>
<li>
<strong>精灵</strong> 需要 有 <strong>两个重要的属性</strong>
<ul>
<li><code>image</code> 要显示的图像</li>
<li><code>rect</code> 图像要显示在屏幕的位置</li>
</ul>
</li>
<li>
<p>默认的 <code>update()</code> 方法什么事情也没做</p>
<ul>
<li>子类可以重写此方法，在每次刷新屏幕时，更新精灵位置</li>
</ul>
</li>
<li>
<p><strong>注意</strong>：<code>pygame.sprite.Sprite</code> 并没有提供 <code>image</code> 和 <code>rect</code> 两个属性</p>
<ul>
<li>需要程序员从 <code>pygame.sprite.Sprite</code> 派生子类</li>
<li>并在 <strong>子类</strong> 的 <strong>初始化方法</strong> 中，设置 <code>image</code> 和 <code>rect</code> 属性</li>
</ul>
</li>
</ul>
<h4>精灵组</h4>
<ul>
<li>一个 <strong>精灵组</strong> 可以包含多个 <strong>精灵</strong> 对象</li>
<li>
调用 <strong>精灵组</strong> 对象的 <code>update()</code> 方法
<ul>
<li>可以 <strong>自动</strong> 调用 <strong>组内每一个精灵</strong> 的 <code>update()</code> 方法</li>
</ul>
</li>
<li>
调用 <strong>精灵组</strong> 对象的 <code>draw(屏幕对象)</code> 方法
<ul>
<li>可以将 <strong>组内每一个精灵</strong> 的 <code>image</code> 绘制在 <code>rect</code> 位置</li>
</ul>
</li>
</ul>
<p><code>python
Group(*sprites) -&gt; Group</code></p>
<blockquote>
<p>注意：仍然需要调用 <code>pygame.display.update()</code> 才能在屏幕看到最终结果</p>
</blockquote>
<h3>4.2 派生精灵子类</h3>
<ol>
<li>新建 <code>plane_sprites.py</code> 文件</li>
<li>定义 <code>GameSprite</code> 继承自 <code>pygame.sprite.Sprite</code></li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>如果一个类的 <strong>父类</strong> 不是 <code>object</code></li>
<li>在重写 <strong>初始化方法</strong> 时，<strong>一定要</strong> 先 <code>super()</code> 一下父类的 <code>__init__</code> 方法</li>
<li><strong>保证父类中实现的 <code>__init__</code> 代码能够被正常执行</strong></li>
</ul>
<p><img src="media/15025046487919/007_GameSprite.png" alt="007_GameSprite-w398" /></p>
<p><strong>属性</strong></p>
<ul>
<li><code>image</code> 精灵图像，使用 <code>image_name</code> 加载</li>
<li><code>rect</code> 精灵大小，默认使用图像大小</li>
<li><code>speed</code> 精灵移动速度，默认为 <code>1</code></li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>
<code>update</code> 每次更新屏幕时在游戏循环内调用
<ul>
<li>让精灵的 <code>self.rect.y += self.speed</code></li>
</ul>
</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li><code>image</code> 的 <code>get_rect()</code> 方法，可以返回 <strong>pygame.Rect(0, 0, 图像宽, 图像高)</strong> 的对象</li>
</ul>
<p>```python
import pygame</p>
<p>class GameSprite(pygame.sprite.Sprite):
    &quot;&quot;&quot;游戏精灵基类&quot;&quot;&quot;</p>
<pre><code>def __init__(self, image_name, speed=1):

    # 调用父类的初始化方法
    super().__init__()

    # 加载图像
    self.image = pygame.image.load(image_name)
    # 设置尺寸
    self.rect = self.image.get_rect()
    # 记录速度
    self.speed = speed

def update(self, *args):

    # 默认在垂直方向移动
    self.rect.y += self.speed
</code></pre>

<p>```</p>
<h3>4.3 使用 游戏精灵 和 精灵组 创建敌机</h3>
<p><strong>需求</strong></p>
<ul>
<li>使用刚刚派生的 <strong>游戏精灵</strong> 和 <strong>精灵组</strong> 创建 敌机 并且实现敌机动画</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>
使用 <code>from</code> 导入 <code>plane_sprites</code> 模块 
<ul>
<li><code>from</code> 导入的模块可以 <strong>直接使用</strong></li>
<li><code>import</code> 导入的模块需要通过 <strong>模块名.</strong> 来使用</li>
</ul>
</li>
<li>在 <strong>游戏初始化</strong> 创建 <strong>精灵对象</strong> 和 <strong>精灵组对象</strong></li>
<li>在 <strong>游戏循环中</strong> 让 <strong>精灵组</strong> 分别调用 <code>update()</code> 和 <code>draw(screen)</code> 方法</li>
</ol>
<p><strong>职责</strong></p>
<ul>
<li>
精灵
<ul>
<li>封装 <strong>图像 image</strong>、<strong>位置 rect</strong> 和 <strong>速度 speed</strong></li>
<li>提供 <code>update()</code> 方法，根据游戏需求，<strong>更新位置 rect</strong></li>
</ul>
</li>
<li>
精灵组
<ul>
<li>包含 <strong>多个</strong> <strong>精灵对象</strong></li>
<li><code>update</code> 方法，让精灵组中的所有精灵调用 <code>update</code> 方法更新位置</li>
<li><code>draw(screen)</code> 方法，在 <code>screen</code> 上绘制精灵组中的所有精灵</li>
</ul>
</li>
</ul>
<h4>实现步骤</h4>
<ul>
<li>1) 导入 <code>plane_sprites</code> 模块</li>
</ul>
<p><code>python
from plane_sprites import *</code></p>
<ul>
<li>2) 修改初始化部分代码</li>
</ul>
<p>```python</p>
<h1>创建敌机精灵和精灵组</h1>
<p>enemy1 = GameSprite(&quot;./images/enemy1.png&quot;)
enemy2 = GameSprite(&quot;./images/enemy1.png&quot;, 2)
enemy2.rect.x = 200
enemy_group = pygame.sprite.Group(enemy1, enemy2)
```</p>
<ul>
<li>3) 修改游戏循环部分代码</li>
</ul>
<p>```python</p>
<h1>让敌机组调用 update 和 draw 方法</h1>
<p>enemy<em>group.update()
enemy</em>group.draw(screen)</p>
<h1>更新屏幕显示</h1>
<p>pygame.display.update()
```</p>
<h1>敌机出场</h1>
<h2>目标</h2>
<ul>
<li>使用 <strong>定时器</strong> 添加敌机</li>
<li>设计 <code>Enemy</code> 类</li>
</ul>
<h2>01. 使用定时器添加敌机</h2>
<p>运行 <strong>备课代码</strong>，<strong>观察</strong> 敌机的 <strong>出现规律</strong>：</p>
<ol>
<li>游戏启动后，<strong>每隔 1 秒</strong> 会 <strong>出现一架敌机</strong></li>
<li>每架敌机 <strong>向屏幕下方飞行</strong>，飞行 <strong>速度各不相同</strong></li>
<li>每架敌机出现的 <strong>水平位置</strong> 也不尽相同</li>
<li>当敌机 <strong>从屏幕下方飞出</strong>，不会再飞回到屏幕中</li>
</ol>
<h3>1.1 定时器</h3>
<ul>
<li>在 <code>pygame</code> 中可以使用 <code>pygame.time.set_timer()</code> 来添加 <strong>定时器</strong></li>
<li>所谓 <strong>定时器</strong>，就是 <strong>每隔一段时间</strong>，去 <strong>执行一些动作</strong></li>
</ul>
<p><code>python
set_timer(eventid, milliseconds) -&gt; None</code></p>
<ul>
<li><code>set_timer</code> 可以创建一个 <strong>事件</strong></li>
<li>可以在 <strong>游戏循环</strong> 的 <strong>事件监听</strong> 方法中捕获到该事件</li>
<li>
第 1 个参数 <strong>事件代号</strong> 需要基于常量 <code>pygame.USEREVENT</code> 来指定
<ul>
<li><code>USEREVENT</code> 是一个整数，再增加的事件可以使用 <code>USEREVENT + 1</code> 指定，依次类推...</li>
</ul>
</li>
<li>第 2 个参数是 <strong>事件触发</strong> 间隔的 <strong>毫秒值</strong></li>
</ul>
<p><strong>定时器事件的监听</strong></p>
<ul>
<li>通过 <code>pygame.event.get()</code> 可以获取当前时刻所有的 <strong>事件列表</strong></li>
<li><strong>遍历列表</strong> 并且判断 <code>event.type</code> 是否等于 <code>eventid</code>，如果相等，表示 <strong>定时器事件</strong> 发生</li>
</ul>
<h3>1.2 定义并监听创建敌机的定时器事件</h3>
<p><code>pygame</code> 的 <strong>定时器</strong> 使用套路非常固定：</p>
<ol>
<li>定义 <strong>定时器常量</strong> —— <code>eventid</code></li>
<li>在 <strong>初始化方法</strong> 中，调用 <code>set_timer</code> 方法 <strong>设置定时器事件</strong></li>
<li>在 <strong>游戏循环</strong> 中，<strong>监听定时器事件</strong></li>
</ol>
<h4>1) 定义事件</h4>
<ul>
<li>在 <code>plane_sprites.py</code> 的顶部定义 <strong>事件常量</strong></li>
</ul>
<p>```python</p>
<h1>敌机的定时器事件常量</h1>
<p>CREATE<em>ENEMY</em>EVENT = pygame.USEREVENT
```</p>
<ul>
<li>在 <code>PlaneGame</code> 的 <strong>初始化方法</strong> 中 <strong>创建用户事件</strong></li>
</ul>
<p>```python</p>
<h1>4. 设置定时器事件 - 每秒创建一架敌机</h1>
<p>pygame.time.set<em>timer(CREATE</em>ENEMY_EVENT, 1000)
```</p>
<h4>2) 监听定时器事件</h4>
<ul>
<li>在 <code>__event_handler</code> 方法中增加以下代码：</li>
</ul>
<p>```python
def _<em>event</em>handler(self):</p>
<pre><code>for event in pygame.event.get():

    # 判断是否退出游戏
    if event.type == pygame.QUIT:
        PlaneGame.__game_over()
    elif event.type == CREATE_ENEMY_EVENT:
        print(&quot;敌机出场...&quot;)
</code></pre>

<p>```</p>
<h2>02. 设计 <code>Enemy</code> 类</h2>
<ol>
<li>游戏启动后，<strong>每隔 1 秒</strong> 会 <strong>出现一架敌机</strong></li>
<li>每架敌机 <strong>向屏幕下方飞行</strong>，飞行 <strong>速度各不相同</strong></li>
<li>每架敌机出现的 <strong>水平位置</strong> 也不尽相同</li>
<li>当敌机 <strong>从屏幕下方飞出</strong>，不会再飞回到屏幕中</li>
</ol>
<p><img src="media/15025309517247/014_%E6%B4%BE%E7%94%9FEnemy%E5%AD%90%E7%B1%BB.png" alt="014_派生Enemy子类-w657" /></p>
<ul>
<li>
<strong>初始化方法</strong>
<ul>
<li>指定 <strong>敌机图片</strong></li>
<li><strong>随机</strong> 敌机的 <strong>初始位置</strong> 和 <strong>初始速度</strong></li>
</ul>
</li>
<li>
重写 <strong>update()</strong> 方法
<ul>
<li>判断 <strong>是否飞出屏幕</strong>，如果是，从 <strong>精灵组</strong> 删除</li>
</ul>
</li>
</ul>
<h3>2.1 敌机类的准备</h3>
<ul>
<li>在 <code>plane_sprites</code> 新建 <code>Enemy</code> 继承自 <code>GameSprite</code></li>
<li>重写 <strong>初始化方法</strong>，直接指定 <strong>图片名称</strong></li>
<li>暂时 <strong>不实现</strong> <strong>随机速度</strong> 和 <strong>随机位置</strong> 的指定</li>
<li>重写 <code>update</code> 方法，判断是否飞出屏幕</li>
</ul>
<p>```python
class Enemy(GameSprite):
    &quot;&quot;&quot;敌机精灵&quot;&quot;&quot;</p>
<pre><code>def __init__(self):

    # 1. 调用父类方法，创建敌机精灵，并且指定敌机的图像
    super().__init__(&quot;./images/enemy1.png&quot;)

    # 2. 设置敌机的随机初始速度

    # 3. 设置敌机的随机初始位置

def update(self):

    # 1. 调用父类方法，让敌机在垂直方向运动
    super().update()

    # 2. 判断是否飞出屏幕，如果是，需要将敌机从精灵组删除
    if self.rect.y &gt;= SCREEN_RECT.height:
        print(&quot;敌机飞出屏幕...&quot;)    
</code></pre>

<p>```</p>
<h3>2.2 创建敌机</h3>
<p><strong>演练步骤</strong></p>
<ol>
<li>
在 <code>__create_sprites</code>，添加 <strong>敌机精灵组</strong>
<ul>
<li>敌机是 <strong>定时被创建的</strong>，因此在初始化方法中，不需要创建敌机</li>
</ul>
</li>
<li>
在 <code>__event_handler</code>，创建敌机，并且 <strong>添加到精灵组</strong>
<ul>
<li>调用 <strong>精灵组</strong> 的 <code>add</code> 方法可以 <strong>向精灵组添加精灵</strong></li>
</ul>
</li>
<li>在 <code>__update_sprites</code>，让 <strong>敌机精灵组</strong> 调用 <code>update</code> 和 <code>draw</code> 方法</li>
</ol>
<p><img src="media/15025309517247/006_pygame.SpriteII.png" alt="006_pygame.SpriteII" /></p>
<p><strong>演练代码</strong></p>
<ul>
<li>修改 <code>plane_main</code> 的 <code>__create_sprites</code> 方法</li>
</ul>
<p>```python</p>
<h1>敌机组</h1>
<p>self.enemy_group = pygame.sprite.Group()
```</p>
<ul>
<li>修改 <code>plane_main</code> 的 <code>__update_sprites</code> 方法</li>
</ul>
<p><code>python
self.enemy_group.update()
self.enemy_group.draw(self.screen)</code></p>
<ul>
<li>定时出现敌机</li>
</ul>
<p><code>python
elif event.type == CREATE_ENEMY_EVENT:
    self.enemy_group.add(Enemy())</code></p>
<h3>2.3 随机敌机位置和速度</h3>
<h4>1) 导入模块</h4>
<ul>
<li>在导入模块时，<strong>建议</strong> 按照以下顺序导入</li>
</ul>
<p><code>python
1. 官方标准模块导入
2. 第三方模块导入
3. 应用程序模块导入</code></p>
<ul>
<li>修改 <code>plane_sprites.py</code> 增加 <code>random</code> 的导入</li>
</ul>
<p><code>python
import random</code></p>
<h4>2) 随机位置</h4>
<p><img src="media/15025309517247/015_%E9%A3%9E%E6%9C%BA%E5%88%9D%E5%A7%8B%E4%BD%8D%E7%BD%AE.png" alt="015_飞机初始位置-w360" /></p>
<p>使用 <code>pygame.Rect</code> 提供的 <code>bottom</code> 属性，在指定敌机初始位置时，会比较方便</p>
<ul>
<li><code>bottom = y + height</code></li>
<li><code>y = bottom - height</code></li>
</ul>
<h4>3) 代码实现</h4>
<ul>
<li>修改 <strong>初始化方法</strong>，随机敌机出现 <strong>速度</strong> 和 <strong>位置</strong></li>
</ul>
<p>```python
def <strong>init</strong>(self):</p>
<pre><code># 1. 调用父类方法，创建敌机精灵，并且指定敌机的图像
super().__init__(&quot;./images/enemy1.png&quot;)

# 2. 设置敌机的随机初始速度 1 ~ 3
self.speed = random.randint(1, 3)

# 3. 设置敌机的随机初始位置
self.rect.bottom = 0

max_x = SCREEN_RECT.width - self.rect.width
self.rect.x = random.randint(0, max_x)
</code></pre>

<p>```</p>
<h3>2.4 移出屏幕销毁敌机</h3>
<ul>
<li>敌机移出屏幕之后，如果 <strong>没有撞到英雄</strong>，敌机的历史使命已经终结</li>
<li>需要从 <strong>敌机组</strong> 删除，否则会造成 <strong>内存浪费</strong></li>
</ul>
<h4>检测敌机被销毁</h4>
<ul>
<li><code>__del__</code> 内置方法会在对象被销毁前调用，在开发中，可以用于 <strong>判断对象是否被销毁</strong></li>
</ul>
<p><code>python
def __del__(self):
    print(&quot;敌机挂了 %s&quot; % self.rect)</code></p>
<h4>代码实现</h4>
<p><img src="media/15025309517247/006_pygame.SpriteII.png" alt="006_pygame.SpriteII" /></p>
<ul>
<li>判断敌机是否飞出屏幕，如果是，调用 <code>kill()</code> 方法从所有组中删除</li>
</ul>
<p>```python
def update(self):
    super().update()</p>
<pre><code># 判断敌机是否移出屏幕
if self.rect.y &gt;= SCREEN_RECT.height:
    # 将精灵从所有组中删除
    self.kill()
</code></pre>

<p>```</p>
<h1>碰撞检测</h1>
<h2>目标</h2>
<ul>
<li>了解碰撞检测方法</li>
<li>碰撞实现</li>
</ul>
<h2>01. 了解碰撞检测方法</h2>
<ul>
<li><code>pygame</code> 提供了 <strong>两个非常方便</strong> 的方法可以实现碰撞检测：</li>
</ul>
<h3>pygame.sprite.groupcollide()</h3>
<ul>
<li><strong>两个精灵组</strong> 中 <strong>所有的精灵</strong> 的碰撞检测</li>
</ul>
<p><code>python
groupcollide(group1, group2, dokill1, dokill2, collided = None) -&gt; Sprite_dict</code></p>
<ul>
<li>如果将 <code>dokill</code> 设置为 <code>True</code>，则 <strong>发生碰撞的精灵将被自动移除</strong></li>
<li>
<code>collided</code> 参数是用于 <strong>计算碰撞的回调函数</strong>
<ul>
<li>如果没有指定，则每个精灵必须有一个 <code>rect</code> 属性</li>
</ul>
</li>
</ul>
<h3>pygame.sprite.spritecollide()</h3>
<ul>
<li>判断 <strong>某个精灵</strong> 和 <strong>指定精灵组</strong> 中的精灵的碰撞</li>
</ul>
<p><code>python
spritecollide(sprite, group, dokill, collided = None) -&gt; Sprite_list</code></p>
<ul>
<li>如果将 <code>dokill</code> 设置为 <code>True</code>，则 <strong>指定精灵组</strong> 中 <strong>发生碰撞的精灵将被自动移除</strong></li>
<li>
<code>collided</code> 参数是用于 <strong>计算碰撞的回调函数</strong>
<ul>
<li>如果没有指定，则每个精灵必须有一个 <code>rect</code> 属性</li>
</ul>
</li>
<li>返回 <strong>精灵组</strong> 中跟 <strong>精灵</strong> 发生碰撞的 <strong>精灵列表</strong></li>
</ul>
<h2>02. 碰撞实现</h2>
<p>```python
def _<em>check</em>collide(self):</p>
<pre><code># 1. 子弹摧毁敌机
pygame.sprite.groupcollide(self.hero.bullets, self.enemy_group, True, True)

# 2. 敌机撞毁英雄
enemies = pygame.sprite.spritecollide(self.hero, self.enemy_group, True)

# 判断列表时候有内容
if len(enemies) &gt; 0:

    # 让英雄牺牲
    self.hero.kill()

    # 结束游戏
    PlaneGame.__game_over()
</code></pre>

<p>```</p>
<h1>项目实战 —— 飞机大战</h1>
<h2>目标</h2>
<ul>
<li>强化 <strong>面向对象</strong> 程序设计</li>
<li>体验使用 <code>pygame</code> 模块进行 <strong>游戏开发</strong></li>
</ul>
<h2>实战步骤</h2>
<ol>
<li><code>pygame</code> 快速体验</li>
<li><strong>飞机大战</strong> 实战</li>
</ol>
<h2>确认模块 —— pygame</h2>
<ul>
<li><code>pygame</code> 就是一个 Python 模块，专为电子游戏设计</li>
<li>
官方网站：https://www.pygame.org/
<ul>
<li><strong>提示</strong>：要学习第三方模块，通常最好的参考资料就在官方网站</li>
</ul>
</li>
</ul>
<p>| 网站栏目 | 内容 |
| --- | --- |
| <code>GettingStarted</code> | 在各平台安装模块的说明 |
| <code>Docs</code> | <code>pygame</code> 模块所有 <strong>类</strong> 和 <strong>子类</strong> 的参考手册 |</p>
<h3>安装 pygame</h3>
<p><code>bash
$ sudo pip3 install pygame</code></p>
<h3>验证安装</h3>
<p><code>bash
$ python3 -m pygame.examples.aliens</code></p>
<h1>英雄登场</h1>
<h2>目标</h2>
<ul>
<li>设计 <strong>英雄</strong> 和 <strong>子弹</strong> 类</li>
<li>使用 <code>pygame.key.get_pressed()</code> 移动英雄</li>
<li>发射子弹</li>
</ul>
<h2>01. 设计 <strong>英雄</strong> 和 <strong>子弹</strong> 类</h2>
<h3>英雄需求</h3>
<ol>
<li>游戏启动后，<strong>英雄</strong> 出现在屏幕的 <strong>水平中间</strong> 位置，距离 <strong>屏幕底部</strong> <code>120</code> <strong>像素</strong></li>
<li><strong>英雄</strong> 每隔 <code>0.5</code> 秒发射一次子弹，每次 <strong>连发三枚子弹</strong></li>
<li><strong>英雄</strong> 默认不会移动，需要通过 <strong>左/右</strong> 方向键，控制 <strong>英雄</strong> 在水平方向移动</li>
</ol>
<p><img src="media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AE.png" alt="017_英雄位置-w480" /></p>
<h3>子弹需求</h3>
<ol>
<li><strong>子弹</strong> 从 <strong>英雄</strong> 的正上方发射 <strong>沿直线</strong> 向 <strong>上方</strong> 飞行</li>
<li><strong>飞出屏幕后</strong>，需要从 <strong>精灵组</strong> 中删除</li>
</ol>
<p><img src="media/15025349250200/016_%E6%B4%BE%E7%94%9F%E8%8B%B1%E9%9B%84%E5%92%8C%E5%AD%90%E5%BC%B9%E5%AD%90%E7%B1%BB.png" alt="016_派生英雄和子弹子类" /></p>
<h3>Hero —— 英雄</h3>
<ul>
<li>
<strong>初始化方法</strong>
<ul>
<li>指定 <strong>英雄图片</strong></li>
<li><strong>初始速度 = 0</strong> —— 英雄默认静止不动</li>
<li>定义 <code>bullets</code> <strong>子弹精灵组</strong> 保存子弹精灵</li>
</ul>
</li>
<li>
重写 <strong>update()</strong> 方法
<ul>
<li>英雄需要 <strong>水平移动</strong></li>
<li>并且需要保证不能 <strong>移出屏幕</strong></li>
</ul>
</li>
<li>增加 <code>bullets</code> 属性，记录所有 <strong>子弹精灵</strong></li>
<li>增加 <code>fire</code> 方法，用于发射子弹</li>
</ul>
<h3>Bullet —— 子弹</h3>
<ul>
<li>
<strong>初始化方法</strong>
<ul>
<li>指定 <strong>子弹图片</strong></li>
<li><strong>初始速度 = -2</strong> —— 子弹需要向上方飞行</li>
</ul>
</li>
<li>
重写 <strong>update()</strong> 方法
<ul>
<li>判断 <strong>是否飞出屏幕</strong>，如果是，从 <strong>精灵组</strong> 删除</li>
</ul>
</li>
</ul>
<h2>02. 创建英雄</h2>
<h3>2.1 准备英雄类</h3>
<ul>
<li>在 <code>plane_sprites</code> 新建 <code>Hero</code> 类</li>
<li>重写 <strong>初始化方法</strong>，直接指定 <strong>图片名称</strong>，并且将初始速度设置为 <code>0</code></li>
<li>设置 <strong>英雄的初始位置</strong></li>
</ul>
<p><img src="media/15025349250200/003_pygame.Rect.png" alt="003_pygame.Rect-w382" /></p>
<ul>
<li><code>centerx = x + 0.5 * width</code></li>
<li><code>centery = y + 0.5 * height</code></li>
<li><code>bottom = y + height</code></li>
</ul>
<p><img src="media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AE.png" alt="017_英雄位置-w480" /></p>
<p>```python
class Hero(GameSprite):
    &quot;&quot;&quot;英雄精灵&quot;&quot;&quot;</p>
<pre><code>def __init__(self):

    super().__init__(&quot;./images/me1.png&quot;, 0)

    # 设置初始位置
    self.rect.centerx = SCREEN_RECT.centerx
    self.rect.bottom = SCREEN_RECT.bottom - 120
</code></pre>

<p>```</p>
<h3>2.2 绘制英雄</h3>
<ol>
<li>
在 <code>__create_sprites</code>，添加 <strong>英雄精灵</strong> 和 <strong>英雄精灵组</strong>
<ul>
<li>后续要针对 <strong>英雄</strong> 做 <strong>碰撞检测</strong> 以及 <strong>发射子弹</strong></li>
<li>所以 <strong>英雄</strong> 需要 <strong>单独定义成属性</strong></li>
</ul>
</li>
<li>在 <code>__update_sprites</code>，让 <strong>英雄精灵组</strong> 调用 <code>update</code> 和 <code>draw</code> 方法</li>
</ol>
<h4>代码实现</h4>
<ul>
<li>修改 <code>__create_sprites</code> 方法如下：</li>
</ul>
<p>```python</p>
<h1>英雄组</h1>
<p>self.hero = Hero()
self.hero_group = pygame.sprite.Group(self.hero)
```</p>
<ul>
<li>修改 <code>__update_sprites</code> 方法如下：</li>
</ul>
<p><code>python
self.hero_group.update()
self.hero_group.draw(self.screen)</code></p>
<h2>03. 移动英雄位置</h2>
<blockquote>
<p>在 <code>pygame</code> 中针对 <strong>键盘按键的捕获</strong>，有 <strong>两种</strong> 方式</p>
</blockquote>
<ul>
<li><strong>第一种方式</strong> 判断 <code>event.type == pygame.KEYDOWN</code></li>
<li>
<strong>第二种方式</strong> 
<ol>
<li>首先使用 <code>pygame.key.get_pressed()</code> 返回 <strong>所有按键元组</strong></li>
<li>通过 <strong>键盘常量</strong>，判断元组中 <strong>某一个键是否被按下</strong> —— 如果被按下，对应数值为 <code>1</code></li>
</ol>
</li>
</ul>
<p><strong>提问</strong> 这两种方式之间有什么区别呢？</p>
<ul>
<li>第一种方式</li>
</ul>
<p><code>python
elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
    print(&quot;向右移动...&quot;)</code></p>
<ul>
<li>第二种方式</li>
</ul>
<p>```python</p>
<h1>返回所有按键的元组，如果某个键被按下，对应的值会是1</h1>
<p>keys<em>pressed = pygame.key.get</em>pressed()</p>
<h1>判断是否按下了方向键</h1>
<p>if keys<em>pressed[pygame.K</em>RIGHT]:
    print(&quot;向右移动...&quot;)
```</p>
<p><strong>结论</strong></p>
<ul>
<li><strong>第一种方式</strong> <code>event.type</code> 用户 <strong>必须要抬起按键</strong> 才算一次 <strong>按键事件</strong>，<strong>操作灵活性会大打折扣</strong></li>
<li><strong>第二种方式</strong> 用户可以按住方向键不放，就能够实现持续向某一个方向移动了，<strong>操作灵活性更好</strong></li>
</ul>
<h3>3.1 移动英雄位置</h3>
<p><strong>演练步骤</strong></p>
<ol>
<li>
在 <code>Hero</code> 类中重写 <code>update</code> 方法
<ul>
<li>用 <strong>速度</strong> <code>speed</code> 和 <strong>英雄</strong> <code>rect.x</code> 进行叠加</li>
<li><strong>不需要调用父类方法</strong> —— 父类方法只是实现了单纯的垂直运动</li>
</ul>
</li>
<li>
在 <code>__event_handler</code> 方法中根据 <strong>左右方向键</strong> 设置英雄的 <strong>速度</strong>
<ul>
<li><strong>向右</strong> =&gt; <code>speed = 2</code></li>
<li><strong>向左</strong> =&gt; <code>speed = -2</code></li>
<li><strong>其他</strong> =&gt; <code>speed = 0</code></li>
</ul>
</li>
</ol>
<p><strong>代码演练</strong></p>
<ul>
<li>在 <code>Hero</code> 类，重写 <code>update()</code> 方法，<strong>根据速度水平移动</strong> 英雄的飞机</li>
</ul>
<p>```python
def update(self):</p>
<pre><code># 飞机水平移动
self.rect.x += self.speed
</code></pre>

<p>```</p>
<ul>
<li>调整键盘按键代码</li>
</ul>
<p>```python</p>
<h1>获取用户按键</h1>
<p>keys<em>pressed = pygame.key.get</em>pressed()</p>
<p>if keys<em>pressed[pygame.K</em>RIGHT]:
    self.hero.speed = 2
elif keys<em>pressed[pygame.K</em>LEFT]:
    self.hero.speed = -2
else:
    self.hero.speed = 0
```</p>
<h3>3.2 控制英雄运动边界</h3>
<ul>
<li>在 <code>Hero</code> 类的 <code>update()</code> 方法判断 <strong>英雄</strong> 是否超出 <strong>屏幕边界</strong></li>
</ul>
<p><img src="media/15025349250200/003_pygame.Rect.png" alt="003_pygame.Rect-w382" /></p>
<ul>
<li><code>right = x + width</code> 利用 <code>right</code> 属性可以非常容易的针对右侧设置精灵位置</li>
</ul>
<p><img src="media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AEII.png" alt="017_英雄位置II-w408" /></p>
<p>```python
def update(self):</p>
<pre><code># 飞机水平移动
self.rect.x += self.speed

# 判断屏幕边界
if self.rect.left &lt; 0:
    self.rect.left = 0
if self.rect.right &gt; SCREEN_RECT.right:
    self.rect.right = SCREEN_RECT.right
</code></pre>

<p>```</p>
<h2>04. 发射子弹</h2>
<h3>需求回顾 —— 英雄需求</h3>
<ol>
<li>游戏启动后，<strong>英雄</strong> 出现在屏幕的 <strong>水平中间</strong> 位置，距离 <strong>屏幕底部</strong> <code>120</code> <strong>像素</strong></li>
<li><strong>英雄</strong> 每隔 <code>0.5</code> 秒发射一次子弹，每次 <strong>连发三枚子弹</strong></li>
<li><strong>英雄</strong> 默认不会移动，需要通过 <strong>左/右</strong> 方向键，控制 <strong>英雄</strong> 在水平方向移动</li>
</ol>
<h3>4.1 添加发射子弹事件</h3>
<p><code>pygame</code> 的 <strong>定时器</strong> 使用套路非常固定：</p>
<ol>
<li>定义 <strong>定时器常量</strong> —— <code>eventid</code></li>
<li>在 <strong>初始化方法</strong> 中，调用 <code>set_timer</code> 方法 <strong>设置定时器事件</strong></li>
<li>在 <strong>游戏循环</strong> 中，<strong>监听定时器事件</strong></li>
</ol>
<p><strong>代码实现</strong></p>
<ul>
<li>在 <code>Hero</code> 中定义 <code>fire</code> 方法</li>
</ul>
<p><code>python
def fire(self):
    print(&quot;发射子弹...&quot;)</code></p>
<ul>
<li>在 <code>plane_main.py</code> 的顶部定义 <strong>发射子弹</strong> 事件常量</li>
</ul>
<p>```python</p>
<h1>英雄发射子弹事件</h1>
<p>HERO<em>FIRE</em>EVENT = pygame.USEREVENT + 1
```</p>
<ul>
<li>在 <code>__init__</code> 方法末尾中添加 <strong>发射子弹</strong> 事件</li>
</ul>
<p>```python</p>
<h1>每隔 0.5 秒发射一次子弹</h1>
<p>pygame.time.set<em>timer(HERO</em>FIRE_EVENT, 500)
```</p>
<ul>
<li>在 <code>__event_handler</code> 方法中让英雄发射子弹</li>
</ul>
<p><code>python
elif event.type == HERO_FIRE_EVENT:
    self.hero.fire()</code></p>
<h3>4.2 定义子弹类</h3>
<h4>需求回顾 —— 子弹需求</h4>
<ol>
<li><strong>子弹</strong> 从 <strong>英雄</strong> 的正上方发射 <strong>沿直线</strong> 向 <strong>上方</strong> 飞行</li>
<li><strong>飞出屏幕后</strong>，需要从 <strong>精灵组</strong> 中删除</li>
</ol>
<h4>Bullet —— 子弹</h4>
<ul>
<li>
<strong>初始化方法</strong>
<ul>
<li>指定 <strong>子弹图片</strong></li>
<li><strong>初始速度 = -2</strong> —— 子弹需要向上方飞行</li>
</ul>
</li>
<li>
重写 <strong>update()</strong> 方法
<ul>
<li>判断 <strong>是否飞出屏幕</strong>，如果是，从 <strong>精灵组</strong> 删除</li>
</ul>
</li>
</ul>
<h4>定义子弹类</h4>
<ul>
<li>在 <code>plane_sprites</code> 新建 <code>Bullet</code> 继承自 <code>GameSprite</code></li>
<li>重写 <strong>初始化方法</strong>，直接指定 <strong>图片名称</strong>，并且设置 <strong>初始速度</strong></li>
<li>重写 <code>update()</code> 方法，判断子弹 <strong>飞出屏幕从精灵组删除</strong></li>
</ul>
<p>```python
class Bullet(GameSprite):
    &quot;&quot;&quot;子弹精灵&quot;&quot;&quot;</p>
<pre><code>def __init__(self):

    super().__init__(&quot;./images/bullet1.png&quot;, -2)

def update(self):

    super().update()

    # 判断是否超出屏幕，如果是，从精灵组删除
    if self.rect.bottom &lt; 0:
        self.kill()
</code></pre>

<p>```</p>
<h3>4.3 发射子弹</h3>
<p><strong>演练步骤</strong></p>
<ol>
<li>在 <code>Hero</code> 的 <strong>初始化方法</strong> 中创建 <strong>子弹精灵组</strong> 属性</li>
<li>修改 <code>plane_main.py</code> 的 <code>__update_sprites</code> 方法，让 <strong>子弹精灵组</strong> 调用 <code>update</code> 和 <code>draw</code> 方法</li>
<li>
实现 <code>fire()</code> 方法
<ul>
<li>创建子弹精灵</li>
<li>设置初始位置 —— 在 <strong>英雄的正上方</strong></li>
<li>将 <strong>子弹</strong> 添加到精灵组</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<ul>
<li>初始化方法</li>
</ul>
<p>```python</p>
<h1>创建子弹的精灵组</h1>
<p>self.bullets = pygame.sprite.Group()
```</p>
<ul>
<li>修改 <code>fire()</code> 方法</li>
</ul>
<p>```python
def fire(self):</p>
<pre><code># 1. 创建子弹精灵
bullet = Bullet()

# 2. 设置精灵的位置
bullet.rect.bottom = self.rect.y - 20
bullet.rect.centerx = self.rect.centerx

# 3. 将精灵添加到精灵组
self.bullets.add(bullet)
</code></pre>

<p>```</p>
<h4>一次发射三枚子弹</h4>
<p><img src="media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AEIII.png" alt="017_英雄位置III-w559" /></p>
<ul>
<li>修改 <code>fire()</code> 方法，一次发射三枚子弹</li>
</ul>
<p>```python
def fire(self):</p>
<pre><code>for i in (1, 2, 3):
    # 1. 创建子弹精灵
    bullet = Bullet()

    # 2. 设置精灵的位置
    bullet.rect.bottom = self.rect.y - i * 20
    bullet.rect.centerx = self.rect.centerx

    # 3. 将精灵添加到精灵组
    self.bullets.add(bullet)
</code></pre>

<p>```</p>
<h1>游戏背景</h1>
<h2>目标</h2>
<ul>
<li>背景交替滚动的思路确定</li>
<li>显示游戏背景</li>
</ul>
<h2>01. 背景交替滚动的思路确定</h2>
<p>运行 <strong>备课代码</strong>，<strong>观察</strong> 背景图像的显示效果：</p>
<ul>
<li>游戏启动后，<strong>背景图像</strong> 会 <strong>连续不断地</strong> <strong>向下方</strong> 移动</li>
<li>
在 <strong>视觉上</strong> 产生英雄的飞机不断向上方飞行的 <strong>错觉</strong> —— 在很多跑酷类游戏中常用的套路
<ul>
<li><strong>游戏的背景</strong> 不断变化</li>
<li><strong>游戏的主角</strong> 位置保持不变</li>
</ul>
</li>
</ul>
<h3>1.1 实现思路分析</h3>
<p><img src="media/15025262948537/013_%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BA%A4%E6%9B%BF%E6%BB%9A%E5%8A%A8.png" alt="013_背景图片交替滚动-w640" /></p>
<p><strong>解决办法</strong></p>
<ol>
<li>
创建两张背景图像精灵
<ul>
<li>第 <code>1</code> 张 <strong>完全和屏幕重合</strong></li>
<li>第 <code>2</code> 张在 <strong>屏幕的正上方</strong></li>
</ul>
</li>
<li>
两张图像 <strong>一起向下方运动</strong>
<ul>
<li><code>self.rect.y += self.speed</code></li>
</ul>
</li>
<li>当 <strong>任意背景精灵</strong> 的 <code>rect.y &gt;= 屏幕的高度</code> 说明已经 <strong>移动到屏幕下方</strong></li>
<li>
将 <strong>移动到屏幕下方的这张图像</strong> 设置到 <strong>屏幕的正上方</strong>
<ul>
<li><code>rect.y = -rect.height</code>  
</li>
</ul>
</li>
</ol>
<h3>1.2 设计背景类</h3>
<p><img src="media/15025262948537/012_%E6%B4%BE%E7%94%9FBackground%E5%AD%90%E7%B1%BB.png" alt="012_派生Background子类-w398" /></p>
<ul>
<li>
<strong>初始化方法</strong>
<ul>
<li>直接指定 <strong>背景图片</strong></li>
<li>
<code>is_alt</code> 判断是否是另一张图像
<ul>
<li><code>False</code> 表示 <strong>第一张图像</strong>，需要与屏幕重合</li>
<li><code>True</code> 表示 <strong>另一张图像</strong>，在屏幕的正上方</li>
</ul>
</li>
</ul>
</li>
<li>
<strong>update()</strong> 方法
<ul>
<li>判断 <strong>是否移动出屏幕</strong>，如果是，将图像设置到 <strong>屏幕的正上方</strong>，从而实现 <strong>交替滚动</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>继承</strong> 如果父类提供的方法，不能满足子类的需求：</p>
<ul>
<li>派生一个子类</li>
<li>在子类中针对特有的需求，重写父类方法，并且进行扩展</li>
</ul>
</blockquote>
<h2>02. 显示游戏背景</h2>
<h3>2.1 背景精灵的基本实现</h3>
<ul>
<li>在 <code>plane_sprites</code> 新建 <code>Background</code> 继承自 <code>GameSprite</code></li>
</ul>
<p>```python
class Background(GameSprite):
    &quot;&quot;&quot;游戏背景精灵&quot;&quot;&quot;</p>
<pre><code>def update(self):

    # 1. 调用父类的方法实现
    super().update()

    # 2. 判断是否移出屏幕，如果移出屏幕，将图像设置到屏幕的上方
    if self.rect.y &gt;= SCREEN_RECT.height:
        self.rect.y = -self.rect.height
</code></pre>

<p>```</p>
<h3>2.2 在 <code>plane_main.py</code> 中显示背景精灵</h3>
<ol>
<li>在 <code>__create_sprites</code> 方法中创建 <strong>精灵</strong> 和 <strong>精灵组</strong></li>
<li>在 <code>__update_sprites</code> 方法中，让 <strong>精灵组</strong> 调用 <code>update()</code> 和 <code>draw()</code> 方法</li>
</ol>
<blockquote>
<p><code>__create_sprites</code> 方法</p>
</blockquote>
<p>```python
def _<em>create</em>sprites(self):</p>
<pre><code># 创建背景精灵和精灵组
bg1 = Background(&quot;./images/background.png&quot;)
bg2 = Background(&quot;./images/background.png&quot;)
bg2.rect.y = -bg2.rect.height

self.back_group = pygame.sprite.Group(bg1, bg2)
</code></pre>

<p>```</p>
<blockquote>
<p><code>__update_sprites</code> 方法</p>
</blockquote>
<p>```python
def _<em>update</em>sprites(self):</p>
<pre><code>self.back_group.update()
self.back_group.draw(self.screen)
</code></pre>

<p>``` </p>
<h3>2.3 利用初始化方法，简化背景精灵创建</h3>
<blockquote>
<p>思考 —— 上一小结完成的代码存在什么样的问题？能否简化？</p>
</blockquote>
<ul>
<li>在主程序中，创建的<strong>两个背景精灵</strong>，<strong>传入了相同的图像文件路径</strong></li>
<li>创建 <strong>第二个 背景精灵</strong> 时，<strong>在主程序中</strong>，设置背景精灵的图像位置</li>
</ul>
<blockquote>
<p>思考 —— 精灵 <strong>初始位置</strong> 的设置，应该 <strong>由主程序负责</strong>？还是 <strong>由精灵自己负责</strong>？</p>
</blockquote>
<p><strong>答案</strong> —— <strong>由精灵自己负责</strong></p>
<ul>
<li>根据面向对象设计原则，应该将对象的职责，封装到类的代码内部</li>
<li>尽量简化程序调用一方的代码调用</li>
</ul>
<p><img src="media/15025262948537/012_%E6%B4%BE%E7%94%9FBackground%E5%AD%90%E7%B1%BB.png" alt="012_派生Background子类-w398" /></p>
<ul>
<li>
<strong>初始化方法</strong>
<ul>
<li>直接指定 <strong>背景图片</strong></li>
<li>
<code>is_alt</code> 判断是否是另一张图像
<ul>
<li><code>False</code> 表示 <strong>第一张图像</strong>，需要与屏幕重合</li>
<li><code>True</code> 表示 <strong>另一张图像</strong>，在屏幕的正上方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在 <code>plane_sprites.py</code> 中实现 <code>Background</code> 的 <strong>初始化方法</strong></p>
<p>```python
def <strong>init</strong>(self, is_alt=False):</p>
<pre><code>image_name = &quot;./images/background.png&quot;
super().__init__(image_name)

# 判断是否交替图片，如果是，将图片设置到屏幕顶部
if is_alt:
    self.rect.y = -self.rect.height     
</code></pre>

<p>```</p>
<ul>
<li>修改 <code>plane_main</code> 的 <code>__create_sprites</code> 方法</li>
</ul>
<p>```python</p>
<h1>创建背景精灵和精灵组</h1>
<p>bg1 = Background()
bg2 = Background(True)</p>
<p>self.back_group = pygame.sprite.Group(bg1, bg2)
```</p>
<h1>游戏框架搭建</h1>
<p><strong>目标</strong> —— 使用 <strong>面相对象</strong> 设计 <strong>飞机大战游戏类</strong></p>
<h2>目标</h2>
<ul>
<li>明确主程序职责</li>
<li>实现主程序类</li>
<li>准备游戏精灵组</li>
</ul>
<h2>01. 明确主程序职责</h2>
<ul>
<li>
回顾 <strong>快速入门案例</strong>，一个游戏主程序的 <strong>职责</strong> 可以分为两个部分：
<ul>
<li>游戏初始化</li>
<li>游戏循环</li>
</ul>
</li>
<li>根据明确的职责，设计 <code>PlaneGame</code> 类如下：</li>
</ul>
<p><img src="media/15025159832322/009_%E6%B8%B8%E6%88%8F%E4%B8%BB%E7%A8%8B%E5%BA%8F.png" alt="009_游戏主程序-w600" /></p>
<blockquote>
<p><strong>提示</strong> 根据 <strong>职责</strong> 封装私有方法，可以避免某一个方法的代码写得太过冗长</p>
<p>如果某一个方法编写的太长，既不好阅读，也不好维护！</p>
</blockquote>
<ul>
<li><strong>游戏初始化</strong> ——  <code>__init__()</code> 会调用以下方法： </li>
</ul>
<p>| 方法 | 职责 |
| --- | --- |
| <code>__create_sprites(self)</code> | 创建所有精灵和精灵组 |</p>
<ul>
<li><strong>游戏循环</strong> —— <code>start_game()</code> 会调用以下方法：</li>
</ul>
<p>| 方法 | 职责 |
| --- | --- |
| <code>__event_handler(self)</code> | 事件监听 |
| <code>__check_collide(self)</code> | 碰撞检测 —— 子弹销毁敌机、敌机撞毁英雄 |
| <code>__update_sprites(self)</code> | 精灵组更新和绘制 |
| <code>__game_over()</code> | 游戏结束 |</p>
<h2>02. 实现飞机大战主游戏类</h2>
<h3>2.1 明确文件职责</h3>
<p><img src="media/15025159832322/011_%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E8%81%8C%E8%B4%A3.png" alt="011_程序文件职责-w479" /></p>
<ul>
<li>
<code>plane_main</code> 
<ol>
<li>封装 <strong>主游戏类</strong></li>
<li>创建 <strong>游戏对象</strong></li>
<li><strong>启动游戏</strong></li>
</ol>
</li>
<li>
<code>plane_sprites</code>
<ul>
<li>封装游戏中 <strong>所有</strong> 需要使用的 <strong>精灵子类</strong></li>
<li>提供游戏的 <strong>相关工具</strong></li>
</ul>
</li>
</ul>
<h4>代码实现</h4>
<ul>
<li>新建 <code>plane_main.py</code> 文件，并且设置为可执行</li>
<li>编写 <strong>基础代码</strong></li>
</ul>
<p>```python
import pygame
from plane_sprites import *</p>
<p>class PlaneGame(object):
    &quot;&quot;&quot;飞机大战主游戏&quot;&quot;&quot;</p>
<pre><code>def __init__(self):
    print(&quot;游戏初始化&quot;)

def start_game(self):
    print(&quot;开始游戏...&quot;)
</code></pre>

<p>if <strong>name</strong> == '<strong>main</strong>':
    # 创建游戏对象
    game = PlaneGame()</p>
<pre><code># 开始游戏
game.start_game()
</code></pre>

<p>```</p>
<h3>2.3 游戏初始化部分</h3>
<ul>
<li>完成 <code>__init__()</code> 代码如下：</li>
</ul>
<p>```python
def <strong>init</strong>(self):
    print(&quot;游戏初始化&quot;)</p>
<pre><code># 1. 创建游戏的窗口
self.screen = pygame.display.set_mode((480, 700))
# 2. 创建游戏的时钟
self.clock = pygame.time.Clock()
# 3. 调用私有方法，精灵和精灵组的创建
self.__create_sprites()
</code></pre>

<p>def _<em>create</em>sprites(self):
    pass
```</p>
<h4>使用 常量 代替固定的数值</h4>
<blockquote>
<ul>
<li>常量 —— 不变化的量</li>
<li>变量 —— 可以变化的量</li>
</ul>
</blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>在开发时，可能会需要使用 <strong>固定的数值</strong>，例如 <strong>屏幕的高度</strong> 是 <code>700</code></li>
<li>这个时候，建议 <strong>不要</strong> 直接使用固定数值，而应该使用 <strong>常量</strong></li>
<li>在开发时，为了保证代码的可维护性，尽量不要使用 <strong>魔法数字</strong> </li>
</ul>
<p><strong>常量的定义</strong></p>
<ul>
<li>定义 <strong>常量</strong> 和 定义 <strong>变量</strong> 的语法完全一样，都是使用 <strong>赋值语句</strong></li>
<li><strong>常量</strong> 的 <strong>命名</strong> 应该 <strong>所有字母都使用大写</strong>，<strong>单词与单词之间使用下划线连接</strong></li>
</ul>
<p><strong>常量的好处</strong></p>
<ul>
<li>阅读代码时，通过 <strong>常量名</strong> <strong>见名之意</strong>，不需要猜测数字的含义</li>
<li>如果需要 <strong>调整值</strong>，只需要 <strong>修改常量定义</strong> 就可以实现 <strong>统一修改</strong></li>
</ul>
<blockquote>
<p>提示：Python 中并没有真正意义的常量，只是通过命名的约定 —— 所有字母都是大写的就是常量，开发时不要轻易的修改！</p>
</blockquote>
<p><strong>代码调整</strong></p>
<ul>
<li>在 <code>plane_sprites.py</code> 中增加常量定义</li>
</ul>
<p>```python
import pygame</p>
<h1>游戏屏幕大小</h1>
<p>SCREEN_RECT = pygame.Rect(0, 0, 480, 700)
```</p>
<ul>
<li>修改 <code>plane_main.py</code> 中的窗口大小</li>
</ul>
<p><code>python
self.screen = pygame.display.set_mode(SCREEN_RECT.size)</code></p>
<h3>2.4 游戏循环部分</h3>
<ul>
<li>完成 <code>start_game()</code> 基础代码如下：</li>
</ul>
<p>```python
def start_game(self):
    &quot;&quot;&quot;开始游戏&quot;&quot;&quot;</p>
<pre><code>print(&quot;开始游戏...&quot;)

while True:

    # 1. 设置刷新帧率
    self.clock.tick(60)

    # 2. 事件监听
    self.__event_handler()

    # 3. 碰撞检测
    self.__check_collide()

    # 4. 更新精灵组
    self.__update_sprites()

    # 5. 更新屏幕显示
    pygame.display.update()
</code></pre>

<p>def _<em>event</em>handler(self):
    &quot;&quot;&quot;事件监听&quot;&quot;&quot;</p>
<pre><code>for event in pygame.event.get():

    if event.type == pygame.QUIT:
        PlaneGame.__game_over()
</code></pre>

<p>def _<em>check</em>collide(self):
    &quot;&quot;&quot;碰撞检测&quot;&quot;&quot;
    pass</p>
<p>def _<em>update</em>sprites(self):
    &quot;&quot;&quot;更新精灵组&quot;&quot;&quot;
    pass</p>
<p>@staticmethod
def _<em>game</em>over():
   &quot;&quot;&quot;游戏结束&quot;&quot;&quot;</p>
<p>print(&quot;游戏结束&quot;)
   pygame.quit()
   exit()
```</p>
<h2>03. 准备游戏精灵组</h2>
<h3>3.1 确定精灵组</h3>
<p><img src="media/15025159832322/010_%E7%B2%BE%E7%81%B5%E7%BB%84%E7%A1%AE%E5%AE%9A.png" alt="010_精灵组确定-w600" /></p>
<h3>3.2 代码实现</h3>
<ul>
<li>创建精灵组方法</li>
</ul>
<p>```python
def _<em>create</em>sprites(self):
    &quot;&quot;&quot;创建精灵组&quot;&quot;&quot;</p>
<pre><code># 背景组
self.back_group = pygame.sprite.Group()
# 敌机组
self.enemy_group = pygame.sprite.Group()
# 英雄组
self.hero_group = pygame.sprite.Group()
</code></pre>

<p>```</p>
<ul>
<li>更新精灵组方法</li>
</ul>
<p>```python
def _<em>update</em>sprites(self):
    &quot;&quot;&quot;更新精灵组&quot;&quot;&quot;</p>
<pre><code>for group in [self.back_group, self.enemy_group, self.hero_group]:

    group.update()
    group.draw(self.screen)
</code></pre>

<p>```</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
